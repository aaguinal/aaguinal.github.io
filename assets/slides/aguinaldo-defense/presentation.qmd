---
title: "Sequential, Hierarchical, and Analogical <br> Plan Transfer in Robotics"
# title-slide-attributes:
#   data-background-image: assets/title-slide-background.png
#   data-background-size: contain
subtitle: " <br> <i>Doctoral Defense</i> <br><br> Department of Computer Science <br> University of Maryland, College Park"
author: "Angeline Aguinaldo"
# institute: "University of Maryland, College Park"
date: "12/2/2024"
date-format: long
bibliography: assets/ref.bib
footer: "Angeline Aguinaldo - Doctoral Defense - December 2, 2024"
number-sections: false
format:
  revealjs:
    theme: [simple, custom.scss]
    slide-number: true
    logo: assets/umdcslogo.png
    css: style.css
jupyter: julia-1.10
execute: 
  # enabled: false
  cache: true
include-in-header: 
  text: |
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&display=swap');

      .bootstrap-scope {
        /* Import Bootstrap styles within this scope only */
        @import url('https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css');
      }
    </style>
filters:
  - pseudocode
---

## About Me

::: {style="margin-top:30px"}
Ph.D. Candidate in Computer Science at **University of Maryland, College Park**

- Since 2018
- Topos Institute (Research Associate), NIST, Siemens
  
Software Lead and People Supervisor at the **Johns Hopkins University Applied Physics Laboratory** 

- Since 2017
- CDC, NASA, FEMA, Army National Guard, ...

Previously B.S. and M.S. Electrical Engineering from **Drexel University** in Philadelphia, PA in 2017
:::

::: columns

::: {.column width="30%"}
::: {style="text-align:center;"}
![](assets/drexellogo.png){width=150px}
:::
:::

::: {.column width="30%"}
::: {style="text-align:center;"}
![](assets/jhuapllogo.png){width=300px}
:::
:::

::: {.column width="30%"}
::: {style="text-align:center;"}
![](assets/umdlogo.png){width=150px}
:::
:::

:::

::: {.hidden}
$$
  \newcommand{\N}{\mathbb{N}}
  \newcommand{\R}{\mathbb{R}}
  \newcommand{\cat}[1]{\mathsf{#1}}
  \newcommand{\CAT}[1]{\mathsf{#1}}
  \newcommand{\Set}{\CAT{Set}}
  \DeclareMathOperator{\Path}{Path}
  \newcommand{\catSet}[1]{\cat{#1}\text{-}\Set}
  \DeclareMathOperator{\Ob}{Ob}
  \DeclareMathOperator{\Hom}{Hom}
$$
:::

## Structure of the talk

::::{.columns}
:::{.column width=25%}
<!-- ![](assets/qr-code.png){fig-align="center" width="400px"}

::: {style="text-align: center; font-size:130%"}
[tinyurl.com/angeline](https://tinyurl.com/planbot)
::: -->

:::

:::{.column width=50%}

::: {style="font-size:30px;margin-top:70px;"}

1. Motivation for the Research
2. Current Approaches and Gaps
3. My Research
4. Deep Dive: Analogical Plan Transfer
5. Future Work and Conclusion

&nbsp; 

::: {style="text-align:center;"}
Follow along! 

[tinyurl.com/angeline](https://tinyurl.com/planbot)
:::
:::
  
:::
::::

# Motivation for the Research

## What do these two robots have in common? 

:::{style="text-align:center;margin-top:10px;"}
Agility Robotics (_left_) and Brightpick Robot (_right_) showcased during ProMat 2023
:::

::: columns 

::: {.column width="27%" style="text-align: right;margin-top:-20px;"}
::: {data-id="video1"}
[![](assets/AgilityRobotics.gif){height="400"}](https://www.youtube.com/shorts/2zCh_6GO49c)
<!-- {{< video https://www.youtube.com/shorts/EEnpmhcIc0I width="100%" height="100%" >}} -->
:::
:::

::: {.column width="27%" style="text-align: left;margin-top:-20px;"}
::: {data-id="video2"}
[![](assets/Brightpick.gif){height="400"}](https://www.youtube.com/shorts/EEnpmhcIc0I)
<!-- {{< video https://www.youtube.com/shorts/2zCh_6GO49c width="100%" height="100%" >}} -->
:::
:::

:::

::: {.fragment}
::: {style="text-align: center; font-size:150%; margin-top:-40px;"}
_the task_
:::
::: {style="text-align:center; font-size:75%;margin-top:-10px;"}
(your embodiments may vary)
:::
:::

:::{.fragment}
:::{.callout-color2 style="text-align:center;"}
**Reuse old plans to solve new problems without re-planning from scratch.**
:::
:::

## What do I mean by "transferring a plan"?

::: columns

::: {.column width="23%"}
::: {style="text-align:center;"}
::: {data-id="video1"}
[![](assets/AgilityRobotics.gif){height="400"}](https://www.youtube.com/shorts/2zCh_6GO49c)
<!-- {{< video https://www.youtube.com/shorts/EEnpmhcIc0I width="100%" height="100%" >}} -->
:::
:::
:::

:::{.column width="54%"}
::: {style="text-align:center;"}
![](assets/integrated-plan-transfer.svg)
:::
:::

::: {.column width="23%"}
::: {style="text-align:center;"}
::: {data-id="video2"}
[![](assets/Brightpick.gif){height="400"}](https://www.youtube.com/shorts/EEnpmhcIc0I)
<!-- {{< video https://www.youtube.com/shorts/2zCh_6GO49c width="100%" height="100%" >}} -->
:::
:::
:::

:::

:::{style="margin-top:-20px;text-align:left;margin-left:300px;"}
- Transfers whole plans or individual actions
- Can be executed in sequence with other plans
- Results in sound abstract behavior
- Can be adapted to a new environment
:::

## What am I trying to do?

&nbsp;  
&nbsp;  

::: {style="font-size:150%"}

Provide a:

1. [**Conceptual**]{.dark-font-color}

    [_vocabulary used to describe types of transfers_]{style="font-size:80%; color:gray;"}

2. [**Mathematical**]{.dark-font-color}
    
    [_system to validate whether each type of transfer is successful_]{style="font-size:80%; color:gray;"}

[**framework**]{.dark-font-color} for task plan transfer, or [**plan transfer**]{.dark-font-color}, in robotics.

:::

# Current Approaches and Gaps

## What is planning in robotics? {auto-animate="true" auto-animate-easing="ease-in"}

![https://www.aiai.ed.ac.uk/~gwickler/prop-fwd-ssp.html](assets/taskplanning-cropped.png){.absolute top=220 left=-110 width="260"}
![https://robodk.com/blog/robot-motion-planning-made-easy/](assets/motionplanning.jpg){.absolute top=240 right=-110 width="260"}

::: columns

::: {.column width="50%" style="text-align: center;"}
::: {style="margin-left:150px"}
**Task Planning**
:::
:::

::: {.column width="50%" style="text-align: center;"}
::: {style="margin-left:-150px"}
**Motion Planning**
:::
:::

:::

::: r-hstack
<!-- ::: {data-id="circle1" style="background: #d5a6bdb2 url('assets/htn.png') no-repeat center; background-size: 80%; width: 400px; height: 400px; border-radius: 200px; margin: 20px; position: relative; display: flex; justify-content: center; align-items: flex-start; padding-top: 20px; font-size: 24px; color: black;"} -->
::: {data-id="circle1" .planning-fc .planning-bg style="width: 400px; height: 400px; border-radius: 200px; margin-left: 20px; position: relative;"}

::: {style="text-align: left; font-size: 24px; margin-top: 110px; margin-left:30px;"}
Abstract decision-making

Symbolic states

Discrete action space

Algorthmic search
:::

::: {style="margin-top: 50px; display: flex; justify-content: center; align-items: flex-end; font-size: 28px; padding-bottom: 20px;"}
_AI Planning_
:::

:::

<!-- ::: {data-id="circle2" style="background: #f9cb9cb2 url('assets/unimate.png') no-repeat center; background-size: 80%; width: 400px; height: 400px; border-radius: 200px; margin: 20px; position: relative; display: flex; justify-content: center; align-items: flex-start; padding-top: 20px; font-size: 24px; color: black;"} -->
::: {data-id="circle2" .robotics-fc .robotics-bg style="width: 400px; height: 400px; border-radius: 200px; margin: 20px; margin-left: -20px; position: relative;"}

::: {style="text-align: right; font-size: 24px; margin-top: 100px; margin-right:30px;"}
Physical maneuver

Geometric states

Continuous configuration space

Robot kinematics and dynamics
:::

::: {style="margin-top: 60px; display: flex; justify-content: center; align-items: flex-end; font-size: 28px; padding-bottom: 20px;"}
_Robotics_
:::

:::
:::

::: {style="text-align:center; margin-top:30px;"}
1970s - 2000s

[@Nilsson1984, @LozanoPerez1992, @Bresina2005]{style="font-size:70%"}
:::

::: {style="text-align:center;margin-top:-10px"}
[Image creds: [Gerhard Wickler](https://www.aiai.ed.ac.uk/~gwickler/prop-fwd-ssp.html) (task), [RoboDK](https://robodk.com/blog/robot-motion-planning-made-easy/) (motion)]{style="font-size:50%;color:gray;"}
:::

## What is planning in robotics? {auto-animate="true" auto-animate-easing="ease-in"}

![https://www.aiai.ed.ac.uk/~gwickler/prop-fwd-ssp.html](assets/taskplanning-cropped.png){.absolute top=200 left=-110 width="300"}
![https://robodk.com/blog/robot-motion-planning-made-easy/](assets/motionplanning.jpg){.absolute top=220 right=-110 width="300"}

::: columns

::: {.column width="50%" style="text-align: center;"}
::: {style="margin-left:230px"}
**Task Planning**
:::
:::

::: {.column width="50%" style="text-align: center;"}
::: {style="margin-left:-230px"}
**Motion Planning**
:::
:::

:::

::: r-hstack
::: {data-id="circle1" .planning-bg .planning-fc style="width: 400px; height: 400px; border-radius: 200px; margin-left: 0px; position: relative;"}

::: {style="text-align: left; font-size: 18px; margin-top: 110px; margin-left:30px;"}
Abstract decision-making

Symbolic states

Discrete action space

Algorthmic search
:::

::: {style="margin-top: 80px; display: flex; justify-content: center; align-items: flex-end; font-size: 28px; padding-bottom: 20px;"}
_AI Planning_
:::

:::

::: {data-id="circle2" .robotics-bg .robotics-fc style="width: 400px; height: 400px; border-radius: 200px; margin-left: -100px; position: relative;"}

::: {style="text-align: right; font-size: 18px; margin-top: 110px; margin-right:30px;"}
Physical maneuver

Geometric states

Continuous configuration space

Robot kinematics and dynamics
:::

::: {style="margin-top: 80px; display: flex; justify-content: center; align-items: flex-end; font-size: 28px; padding-bottom: 20px;"}
_Robotics_
:::

:::
:::

::: {style="text-align:center; margin-top:30px;"}

(after 2010) **Task and Motion Planning (TAMP)**

Coordinating high-level and low-level planning

[@Kaelbling2011, @Garrett2021, @Mansouri2021]{style="font-size:70%"}
:::

::: {style="text-align:center;margin-top:-10px"}
[Image creds: [Gerhard Wickler](https://www.aiai.ed.ac.uk/~gwickler/prop-fwd-ssp.html) (task), [RoboDK](https://robodk.com/blog/robot-motion-planning-made-easy/) (motion)]{style="font-size:50%;color:gray;"}
:::

## What is plan transfer in robotics? (today)

::: {style="margin-top:30px; font-size:90%"}
**Transfer learning** is the process of reusing knowledge, e.g. models, trained in one domain in another domain:

::: {style="margin-left:20px"}

- _feature spaces_ or _distributions_ in **machine-learning** [@Pan2009]
- _state_ or _action spaces_ in **reinforcement learning (RL)** [@Taylor2009]
- _robot (embodiment)_, _task_, or _environment_ in **robotics** [@Jaquier2023]
  
:::

::: {style="margin-top:10px"}
**Predominant techniques in robotics include:** 

::: {style="margin-left:20px;"}
recalculating motion trajectory through kinematic mapping ([**motion retargeting**]{.define}), 

learning a shared feature space across different environments ([**universal domain adaptation**]{.define}), and 

learning multiple task at once ([**RL meta-learning**]{.define}).
:::
:::

::: columns

::: {.column width="60%"}
![Task transfer can be accomplished using universal domain adaptation or RL meta-learning. Image from [@Jaquier2023].](assets/tasktransfer.png)
:::

::: {.column width="40%"}
![Example of motion retargeting [@Liang2021]](assets/motionretargeting.png)
:::

:::

:::

## What's the gap?

::: {.callout-color style="margin-top:120px; border-radius: 10px; font-size:100%; padding: 10px;"}
**1.** Plan transfer in robotics typically [**focuses on motion planning**]{.define}, neglecting task-level transfer at the symbolic representation.
:::

::: {.callout-color style="margin-top:20px; border-radius: 10px; font-size:100%; padding: 10px;"}
**2.** Current approaches [**lack flexibility in broader transfer use cases**]{.define}, such as partial plan transfer or integrating plans into larger behaviors.
:::

::: {.callout-color style="margin-top:20px; border-radius: 10px; font-size:100%; padding: 10px;"}
**3.** There [**lacks standardized frameworks**]{.define} to formally evaluate the success of plan transfer.
:::

##  What's new in the approach?

::: {.callout-color style="margin-top:20px; border-radius: 10px; font-size:100%; padding: 10px;"}
**1.** Plan transfer in robotics typically [**focuses on motion planning**]{.define}, neglecting task-level transfer at the symbolic representation.
:::

::: {style="margin-top:10px; text-align:left; font-size:100%; margin-left:20px;"}
Focus on task-level transfer.
:::

::: {.callout-color style="margin-top:20px; border-radius: 10px; font-size:100%; padding: 10px;"}
**2.** Current approaches [**lack flexibility in broader transfer use cases**]{.define}, such as partial plan transfer or integrating plans into larger behaviors.
:::

::: {style="margin-top:10px; text-align:left; font-size:100%; margin-left:20px;"}
Identify broader transfer uses cases. The way robot programming has evolved gives a hint to how humans aim to reuse existing robot behaviors.
:::

::: {.callout-color style="margin-top:20px; border-radius: 10px; font-size:100%; padding: 10px;"}
**3.** There [**lacks standardized frameworks**]{.define} to formally evaluate the success of plan transfer.
:::

::: {style="margin-top:20px; text-align:left; font-size:100%; margin-left:20px;"}
Establish a formal framework that can account for all types of transfer. [**Category theory**]{.dark-font-color}, with its emphasis on abstraction and compositionality, is a good candidate for this mathematical framework.
:::

## What is category theory? {visibility="hidden"}

## What is category theory? 

::: columns

::: {.column width="50%"}
::: {style="margin-top:30px;font-size:90%"}
[Category theory]{.define} is a branch of abstract algebra that defines the structures-- [categories]{.define}, [functors]{.define}, and [natural transformations]{.define} [@Eilenberg1945].

Category theory has been applied in many domains^[[@Fong2018], [@Diskin2012], [@Curry2013], [@Robinson2017], ...], and such works contribute to the field of [Applied Category Theory (ACT)]{.define}.
:::
:::

::: {.column width="50%" style="text-align:center;margin-top:-20px"}
![](assets/category.svg)
:::

:::

::: {.callout-color style="font-size:80%;margin-top:-30px;"}
**Definition**: _(Category)_ A [category]{.define}, $\cat{C}$, consists of:

- a collection of [objects]{.define}, $\text{Ob}(\cat{C})$
- a collection of [morphisms]{.define} for every pairs of objects, $\text{Hom}_\cat{C}(X,Y)$ for $X, Y \in \text{Ob}(\cat{C})$
- a composition operation, if $f: X \rightarrow Y$, $g: Y \rightarrow Z$ then $g \circ f: X \rightarrow Z$
- an identity morphism for every object, $1_X: X \rightarrow X$

satisfying the *associativity* law $h \circ (g \circ f) = (h \circ g) \circ f$ and *unitality* laws $f \circ 1_x = f$ and $1_y \circ f = f$ whenever these equations make sense.
:::

## Functors and natural transformations

::: {style="text-align:center;margin-top:-40px"}
![](assets/naturaltransformation.svg){height="400"}
:::

::: {style="margin-top:-65px;"}
::: columns

::: {.column width=70%}
::: {.callout-color style="font-size:70%;"}
**Definition**: _(Functor)_ A [functor]{.define}, $F: \cat{C} \rightarrow \cat{D}$, from a category $\cat{C}$ to a category $\cat{D}$, has two components, $F_0$ and $F_1$, where:

- $F_0$ is a map between objects, $F_0: \text{Ob}(\cat{C}) \rightarrow \text{Ob}(\cat{D})$

- $F_1$ is a map between morphism sets, $F_1: \text{Hom}_\cat{C}(X, Y) \rightarrow \text{Hom}_\cat{D}(F_0(X), F_0(Y))$

such that,

- $F_1(g \circ f) = F_1(g) \circ F_1(f)$ for $f: X \rightarrow Y$ and $g: Y \rightarrow Z$ in $\cat{C}$
- $F_1(1_X) = 1_{F_0(X)}$ for every $X \in \cat{C}$
:::
:::

::: {.column width="30%"}
::: {.callout-color style="font-size:70%;"}
**Informal Definition**: 

_(Natural Transformation)_

For functors, 

$F: \cat{C} \rightarrow \cat{D}$ and $G: \cat{C} \rightarrow \cat{D}$, 

a [natural transformation]{.define} $\alpha: F \rightarrow G$ associates every object in $\cat{C}$ and with a morphism in $\cat{D}$ such that composition in $\cat{C}$ is preserved under $F$ and $G$.
:::
:::
:::

:::

# My Research

## Evolution of robot programming

<!-- unimate, motion primitives, ROCI, program translation, transfer learning
![See [@unimate]](assets/unimate.jpg){.absolute top=250 left=0 width="325"}
![See [@Bogh]](assets/assembly.png){.absolute top=270 left=335 height="275"}
![](assets/ROCI_modules.png){.absolute top=350 left=360 height="200"}
![See [@Freund2001]](assets/programtranslation.png){.absolute top=230 left=800 height="350"} -->

::: columns

::: {.column width="60%"}
:::

::: {.column width="40%"}

::: {.fragment}
![](assets/robotprogramming/1_unimate.jpg){.absolute top=105 left=0 width="500" style="border: 2px solid #000000;"}

::: {style="margin-left:15px"}
**Manual programming** [@brown1967unimate]{style="font-size:80%"}
:::
:::

::: {.fragment}
![](assets/robotprogramming/2_skillsBogh.png){.absolute top=55 left=20 width="550" style="border: 2px solid #000000;"}
![](assets/robotprogramming/2_assemblyIonescu.png){.absolute top=315 left=-30 width="500" style="border: 2px solid #000000;"}
![](assets/robotprogramming/2_crclProctor.png){.absolute top=485 left=260 width="350" style="border: 2px solid #000000;"}

::: {style="margin-left:15px"}
**Motion primitives and skills**
:::

::: {style="margin-left:55px;"}
**"Does your robot have skills?"** [@Bogh]{style="font-size:80%"}, **Assembly** [@Ionescu2020]{style="font-size:80%"}, **CRCL** [@Proctor2016]{style="font-size:80%"}
:::
:::

::: {.fragment}
![](assets/robotprogramming/3_ROCI_modules.png){.absolute top=65 left=-10 width="600" style="border: 2px solid #000000;"}
![](assets/robotprogramming/3_ROCI_example.png){.absolute top=385 left=-10 width="600" style="border: 2px solid #000000;"}

::: {style="margin-left:15px"}
**Modular architectures** [@Cowley2006]{style="font-size:80%"}
:::
:::

<!-- ::: {.fragment}
![](assets/robotprogramming/4_tasktreeKortenkamp.png){.absolute top=250 left=0 width="325"}
Task trees [@Erol1994]{style="font-size:80%"}[(Image from: [@Kortenkamp2008])]{style="font-size:80%"}
::: -->

::: {.fragment}
![](assets/robotprogramming/5_middlewareMatai.png){.absolute top=55 left=-30 width="650" style="border: 2px solid #000000;"}
![](assets/robotprogramming/5_middlewareLiang.png){.absolute top=270 left=-30 width="650" style="border: 2px solid #000000;"}
![](assets/robotprogramming/5_middlewareAragao.png){.absolute top=437 left=-30 width="650" style="border: 2px solid #000000;"}

::: {style="margin-left:15px"}
**Middlewares** [@Aragao2016, @Liang2008, @Matai2008]{style="font-size:80%"}
:::
:::

::: {.fragment}
![](assets/robotprogramming/6_programtranslationFreund.png){.absolute top=45 left=100 width="400" style="border: 2px solid #000000;"}

::: {style="margin-left:15px"}
**Program translation** [@Freund2001, @Freund2002]{style="font-size:80%"}
:::
:::

::: {.fragment}
![](assets/robotprogramming/7_MontiArcAdam2017.png){.absolute top=62 left=-75 width="400" style="border: 2px solid #000000;"}
![](assets/robotprogramming/7_adaptpackSouza2020.png){.absolute top=185 left=330 width="300" style="border: 2px solid #000000;"}
![](assets/robotprogramming/7_adaptpackSouza2019.png){.absolute top=345 left=0 width="600" style="border: 2px solid #000000;"}

::: {style="margin-left:55px;"}
**MontiArcAutomaton** [@Adam2017a, @Ringert2014]{style="font-size:80%"}, **AdaptPack Studio** [@Souza2019, @Souza2020]{style="font-size:80%"}
:::
:::


:::

:::

## The conceptual framework for plan transfer

::: columns 

::: {.column width="33%"}
::: {style="text-align:center;"}
**Sequential Transfer**

![](assets/sequential.svg){width="250"}
:::

::: {style="margin-top:143px; margin-left:30px;"}
- Linear 
- Preserves composition
- Same planning domain
:::

:::

::: {.column width="33%"}
::: {style="text-align:center;"}
**Hierarchical Transfer**

![](assets/hierarchical.svg){width="250"}
:::

::: {style="font-size:100%"}
- Modular
- Preserves composition and high-level behavior
- Same planning domain
:::

:::

::: {.column width="33%"}
::: {style="text-align:center;"}
**Analogical Transfer**

![](assets/analogical.svg){width="250"}
:::

::: {style="margin-top:170px;"}
- Leverages mappings between planning domains
- Preserves plan structure
- Different planning domain
:::

:::

:::

## The mathematical framework and case studies

::: columns 

::: {.column width="33%"}
::: {style="text-align:center;"}
**Sequential Transfer**
:::

![String Diagrams in Blocksworld domain [[@Aguinaldo2021a]]{style="font-size:80%"}](assets/stringdiagrams.png){height="300px" style="border: 2px solid black; border-radius:10px; padding:5px; margin-top:0px;"}

::: {style="margin-top:15px;text-align:center;font-size:70%"}
Using symmetric monoidal categories (SMCs) [[@Joyal1991]]{style="font-size:80%"} and string diagrams [[@Marsden2014]]{style="font-size:80%"} [**to propagate preconditions and effects throughout the plan**]{.define}.
:::

:::

::: {.column width="33%"}
::: {style="text-align:center;"}
**Hierarchical Transfer**
:::

![RoboCat Framework in machine-tending scenario [[@Aguinaldo2021]]{style="font-size:80%"}](assets/robocat.png){style="border: 2px solid black; border-radius:10px; padding:5px; margin-top:0px;"}

::: {style="font-size:100%; text-align:center; margin-top:15px;font-size:70%"}
Using SMCs, monoidal functors, and functors [[@Leinster2016]]{style="font-size:80%"} [**to ensure that high-level abstractions map functorially to low-level abstractions**]{.define}.
:::

:::

::: {.column width="33%"}
::: {style="text-align:center;"}
**Analogical Transfer**
:::

![Plan transfer from Blocksworld to AI2-THOR Kitchenworld [[@Aguinaldo2023] [@Aguinaldo2024]]{style="font-size:80%"}](assets/plan-transfer-concept.png){style="border: 2px solid black; border-radius:10px; padding:5px; margin-top:13px;"}

::: {style="margin-top:23px;text-align:center;font-size:70%"}
Using $\cat{C}$-sets [[@Spivak2011], [@Patterson2021]]{style="font-size:80%"}, double-pushout (DPO) rewriting [[@Brown2021]]{style="font-size:80%"}, and functorial data migrations [[@Spivak2012]]{style="font-size:80%"} [**to ensure that transferred plans preserve the plan structure and adhere to the ontological structure of the target domain**]{.define}.
:::

:::

:::

# Deep Dive: Analogical Plan Transfer

## What can we do with analogical plan transfer?

:::{style="text-align:center;margin-top:20px;"}
![](assets/demo/demo.gif){width="900"}
:::

::: {style="font-size:70%;margin-top:-20px;"}
Kitchenworld simulation from AI2-Thor [@AiTHOR_object_types]
:::

## Why does this work?

::: {.absolute top=480 left=750 width=250 style="font-size:70%;text-align:center;"}
_Kitchenworld ontology derived from AI2-Thor Object Type Documentation [@AiTHOR_object_types]_
:::

![](assets/StructuralAnalogyTranslationFunctor.png)

:::{style="text-align:center;margin-top:-25px;"}
**Uses an ontology alignment map that is** [**functorial**]{.dark-font-color}
:::

## Formal Theory of Analogies

::: columns

::: {.column width="40%"}
![Analogies are formed by structure mappings [[@Gentner2012]]{style="font-size:80%"}](assets/analogy.png){height="500px"}
:::

::: {.column width="60%"}

::: {.callout-color2 style="padding:10px;font-size:90%"}
**Definition:** _(Analogical Transfer)_ Analogical transfer involves identifying structural similarities, or analogies, between planning domains and leveraging these analogies to adapt plans from one context to another. [[@Aguinaldo2024dissertation]]{style="font-size:80%"}
:::

::: {style="font-size:90%"}
**Why analogies?** 

[@Wilkins2001] argued that an ideal system should mimic human behavior by using [**analogies**]{.dark-font-color} to transfer solutions from one problem to another.

**What are analogies?**

According to [@Gentner1983], analogies:

- have a [**one-to-one correspondence**]{.dark-font-color}, each concept in the source domain maps to at most one concept in the target domain
- adhere to the [**systematicity principle**]{.dark-font-color}, where analogical maps connect large, densely connected systems of concepts, instead of just a handful of isolated concepts

<!-- An analogy is judged by [**how much new knowledge**]{.define} can be inferred based on it. -->
:::

<!-- ::: {.callout-color2 style="padding:10px;font-size:80%;"}
Analogical plan transfer is achieved using [**functorial data migrations**]{.define} from category theory. [[@Aguinaldo2024]]{style="font-size:80%"}
::: -->

:::

:::

## Task Planning

::: {style="font-size:90%;margin-top:20px;"}

::: {.callout-color2 style="padding:10px"}
PDDL^[PDDL (Planning Domain Definition Language) [[@Ghallab1998]]{style="font-size:80%"} is a widely used task planning language in AI, including applications in robotics.] does not have built-in support for domain comparison or domain ontology alignment. Therefore, a new planning language that supports these capabilities is a prerequisite for analogical plan transfer. [[@Aguinaldo2024dissertation]]{style="font-size:80%"}
:::

:::

::: columns

::: {.column width="50%"}

:::{.callout-color style="margin-top:30px;font-size:80%"}
**State Transition System Model for Planning** [[@Ghallab2004]]{style="font-size:80%"}

- [States]{.define}, $S = \{s_0, s_1, s_2, \dots\}$ set of all possible states
- [Actions]{.define}, $A = \{a_0, a_1, a_2, \dots\}$ set of all possible actions
  - [Preconditions]{.define}, $\mathrm{Pre}(a)$ conditions that must be true in the state for the action to be applied
  - [Effects]{.define}, $\mathrm{Eff}(a)$ conditions are true in the state after the action is applied
- [Transition function]{.define}, $\gamma: A \times S \rightarrow S$ partial function that maps an action and a state to the resulting state
  - [Checking applicability]{.define} an action $a \in A$ is \textit{applicable} at state $s \in S$ if $\gamma(a, s)$ is defined
:::

:::

::: {.column width="50%"}

::: {style="margin-top:90px"}
![Source: https://www.aiai.ed.ac.uk/~gwickler/prop-fwd-ssp.html](assets/taskplanning.png)
:::

<!-- ::: {style="font-size:90%;margin-top:10px"}
```{.pddl}
(define (domain blocksworld)
(:requirements :strips :equality)
(:predicates (clear ?x)
             (on-table ?x)
             (arm-empty)
             (holding ?x)
             (on ?x ?y))

(:action pickup
  :parameters (?ob)
  :precondition (and (clear ?ob) (on-table ?ob) (arm-empty))
  :effect (and (holding ?ob) (not (clear ?ob)) (not (on-table ?ob)) 
               (not (arm-empty))))

(:action putdown
  :parameters  (?ob)
  :precondition (and (holding ?ob))
  :effect (and (clear ?ob) (arm-empty) (on-table ?ob) 
               (not (holding ?ob))))

(:action stack
  :parameters  (?ob ?underob)
  //:precondition (and  (clear ?underob) (holding ?ob) (not (= ?ob ?underob)) )
  :precondition (and  (clear ?underob) (holding ?ob))
  :effect (and (arm-empty) (clear ?ob) (on ?ob ?underob)
               (not (clear ?underob)) (not (holding ?ob))))

(:action unstack
  :parameters  (?ob ?underob)
  :precondition (and (on ?ob ?underob) (clear ?ob) (arm-empty))
  :effect (and (holding ?ob) (clear ?underob)
               (not (on ?ob ?underob)) (not (clear ?ob)) (not (arm-empty)))))
                      
```

Blocksworld specification^[https://github.com/gerryai/PDDL4J/blob/master/pddl/blockworld/blocksworld.pddl] in the [**Planning Domain Definition Language (PDDL)**]{.dark-font-color} [[@Ghallab1998]]{style="font-size:80%"}
::: -->

:::

:::

## Planning States as $\cat{C}$-sets

:::{style="font-size:90%"}
**Definition**: (_$\cat{C}$-set_, _schema category_) A [$\cat{C}$-set]{.define} is a functor from $\cat{C} \rightarrow \cat{Set}$. $\cat{C}$ is referred to as the [schema category]{.define}. $\cat{Set}$ is a category whose objects are sets and whose morphisms are set function maps.
:::

::: {.callout-color}
**Example:** 

::: {style="text-align:center;"}
A $\cat{C}$-set, $X$, that stores data about what boxes are on which surface. 
:::

::: columns
::: {.column width=50%}
::: {style="margin-top:110px;"}
![](assets/BoxOnSurface-X.png){fig-align="center" height="200"}
:::
:::

::: {.column width=50%}
![](assets/BoxOnSurface-Set.svg){fig-align="center"}
:::
:::

:::

:::{style="font-size:90%"}
The category of elements construction [@Riehl2016] makes $X$ interoperable with RDF triple syntax (subject, predicate, object), facilitating its use in knowledge graphs [@Spivak2012].
:::

## $\cat{ColorBlocksworld}$-set in Code

::: {.div}

::: {.panel-tabset style="margin-top:-10px;"}

### Ontology

:::: {.columns}

::: {.column width="50%;font-size:80%"}
```{julia}
#| echo: false
#| output: false
using Pkg
# cd("/Users/aguinam1/Documents/Git/kr2023-csetplanning/aaai-urrad-presentation/julia")  # use this environment to avoid `constructor` error
cd("julia")
Pkg.activate(".")
include("AlgebraicPlanning.jl")
using PrettyTables
```

```{julia}
#| echo: true
#| output: false
using Catlab
using AlgebraicRewriting

@present OntColorBlocksworld(FreeSchema) begin
  # Types
  Block::Ob
  Empty::Ob
  Gripper::Ob

  HasColor::Ob
  IsClear::Ob
  IsOnTable::Ob
  HasLabel::Ob

  Color::AttrType
  Clear::AttrType
  OnTable::AttrType
  Label::AttrType

  # Predicates
  isEmpty::Hom(Empty, Block)
  isHolding::Hom(Gripper, Block)
  hasColor::Attr(HasColor, Color)
  hasColorDom::Hom(HasColor, Block)
  isClear::Attr(IsClear, Clear)
  isClearDom::Hom(IsClear, Block)
  isOnTable::Attr(IsOnTable, OnTable)
  isOnTableDom::Hom(IsOnTable, Block)
  hasLabel::Attr(HasLabel, Label)
  hasLabelDom::Hom(HasLabel, Block)

  # Relations
  On::Ob
  on_l::Hom(On, Block)
  on_r::Hom(On, Block)
end

# Create a C-set type based on ontology
@acset_type ColorBlocksworld(OntColorBlocksworld)
```
:::

::: {.column width="50%" style="margin-top:80px"}
![$\cat{OntColorBlocksworld}$ Schema Category](assets/ColorBlocksworldSchema.svg){ fig-align="center" width="700"}
:::

::::

### Data

```{julia}
#| echo: false
#| output: false
yColorBlocksworld = yoneda(ColorBlocksworld{String,Bool,Bool,String})
```

::: {#foo .div style="height:50;font-size:80%"}
```{julia}
#| echo: true
#| output: true
#| output-location: column
state = @acset_colim yColorBlocksworld begin
  gripper::Gripper
  empty::Empty

  null::Block
  isHolding(gripper) == null
  isEmpty(empty) == null
  (labelNull)::HasLabel
  hasLabelDom(labelNull) == null
  hasLabel(labelNull) == "null"

  (A, B, C, D, E, F)::Block
  (colorA, colorB, colorC, colorD, colorE, colorF)::HasColor
  hasColorDom(colorA) == A
  hasColorDom(colorB) == B
  hasColorDom(colorC) == C
  hasColorDom(colorD) == D
  hasColorDom(colorE) == E
  hasColorDom(colorF) == F
  hasColor(colorA) == "green"
  hasColor(colorB) == "red"
  hasColor(colorC) == "yellow"
  hasColor(colorD) == "purple"
  hasColor(colorE) == "purple"
  hasColor(colorF) == "blue"

  (labelA, labelB, labelC, labelD, labelE, labelF)::HasLabel
  hasLabelDom(labelA) == A
  hasLabelDom(labelB) == B
  hasLabelDom(labelC) == C
  hasLabelDom(labelD) == D
  hasLabelDom(labelE) == E
  hasLabelDom(labelF) == F
  hasLabel(labelA) == "A"
  hasLabel(labelB) == "B"
  hasLabel(labelC) == "C"
  hasLabel(labelD) == "D"
  hasLabel(labelE) == "E"
  hasLabel(labelF) == "F"

  (x1, x2)::On
  on_l(x1) == E
  on_r(x1) == D
  on_l(x2) == D
  on_r(x2) == C

  (clearA, clearB, clearC, clearD, clearE, clearF)::IsClear
  isClearDom(clearA) == A
  isClearDom(clearB) == B
  isClearDom(clearC) == C
  isClearDom(clearD) == D
  isClearDom(clearE) == E
  isClearDom(clearF) == F
  isClear(clearA) == true
  isClear(clearB) == true
  isClear(clearC) == false
  isClear(clearD) == false
  isClear(clearE) == true
  isClear(clearF) == true

  (onTableA, onTableB, onTableC, onTableD, onTableE, onTableF)::IsOnTable
  isOnTableDom(onTableA) == A
  isOnTableDom(onTableB) == B
  isOnTableDom(onTableC) == C
  isOnTableDom(onTableD) == D
  isOnTableDom(onTableE) == E
  isOnTableDom(onTableF) == F
  isOnTable(onTableA) == true
  isOnTable(onTableB) == true
  isOnTable(onTableC) == true
  isOnTable(onTableD) == false
  isOnTable(onTableD) == false
  isOnTable(onTableE) == false
  isOnTable(onTableF) == true
end
pretty_tables(state)
```

<!-- ![](assets/ColorBlocksworldState.png){.absolute top=465 left=730 width="350"} -->

:::

:::

::: 

:::{style="margin-top:0px;"}
[Uses category theory programming framework provided by [AlgebraicJulia](https://www.algebraicjulia.org/)]{style="font-size:90%"}
:::

## Planning Actions using Spans and DPO Rewriting

**Definition**: The category [$\catSet{C}$]{.define} is a category whose objects are $\cat{C}$-set functors and whose morphisms are natural transformations.

A span in $\catSet{C}$ is a diagram of shape ($\bullet \leftarrow \bullet \rightarrow \bullet$) in $\catSet{C}$.

::: {.callout-color2 style="margin-top:20px;text-align:center;"}

[Actions]{.define} are spans ($\mathrm{Pre} \hookleftarrow \mathrm{Keep} \rightarrow \mathrm{Eff}$) in $\catSet{C}$ 

<!-- https://q.uiver.app/#q=WzAsNixbMCwwLCJcXG1hdGhybXtQcmV9Il0sWzEsMCwiXFxtYXRocm17S2VlcH0iXSxbMiwwLCJcXG1hdGhybXtFZmZ9Il0sWzAsMSwiWCJdLFsyLDEsIlkiXSxbMSwxLCJaIl0sWzEsMCwibCIsMix7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6Imhvb2siLCJzaWRlIjoiYm90dG9tIn19fV0sWzEsMiwiciJdLFsxLDUsImYiLDJdLFswLDMsIm0iLDIseyJzdHlsZSI6eyJ0YWlsIjp7Im5hbWUiOiJob29rIiwic2lkZSI6ImJvdHRvbSJ9fX1dLFs1LDNdLFs1LDRdLFsyLDRdLFs0LDEsIiIsMix7InN0eWxlIjp7Im5hbWUiOiJjb3JuZXIifX1dLFszLDEsIiIsMix7InN0eWxlIjp7Im5hbWUiOiJjb3JuZXIifX1dXQ== -->
<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsNixbMCwwLCJcXG1hdGhybXtQcmV9Il0sWzEsMCwiXFxtYXRocm17S2VlcH0iXSxbMiwwLCJcXG1hdGhybXtFZmZ9Il0sWzAsMSwiWCJdLFsyLDEsIlkiXSxbMSwxLCJaIl0sWzEsMCwibCIsMix7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6Imhvb2siLCJzaWRlIjoiYm90dG9tIn19fV0sWzEsMiwiciJdLFsxLDUsImYiLDJdLFswLDMsIm0iLDIseyJzdHlsZSI6eyJ0YWlsIjp7Im5hbWUiOiJob29rIiwic2lkZSI6ImJvdHRvbSJ9fX1dLFs1LDNdLFs1LDRdLFsyLDRdLFs0LDEsIiIsMix7InN0eWxlIjp7Im5hbWUiOiJjb3JuZXIifX1dLFszLDEsIiIsMix7InN0eWxlIjp7Im5hbWUiOiJjb3JuZXIifX1dXQ==&embed" width="438" height="304" style="border-radius: 8px; border: none;"></iframe>

::: {style="margin-top:-30px"}
Actions are applied to state $X$ to produce state $Y$ using [Double-Pushout (DPO) Rewriting]{.define} 

[[@Aguinaldo2023]]{style="font-size:80%"}
:::

:::

## Actions in $\catSet{ColorBlocksworld}$ in Code

:::: {.columns}

::: {.column width="10%" style="font-size:90%"}
[`unstack` action span written in [AlgebraicJulia](https://www.algebraicjulia.org/)]{style="margin-left:60px;font-size:70%"}

```{julia}
#| echo: true
#| output: false
#| class-source: code-block-narrow
#| classes: code-block-narrow
unstack = @migration SchRule OntColorBlocksworld begin
  L => @join begin
    gripper::Gripper
    empty::Empty
    (block, underblock, null)::Block
    isEmpty(empty) == null

    o::On
    on_l(o) == block
    on_r(o) == underblock

    isHolding(gripper) == null

    clearblock::IsClear
    isClearDom(clearblock) == block
    isClear(clearblock) == true
  end
  K => @join begin
    (block, underblock, null)::Block
  end
  R => @join begin
    gripper::Gripper
    empty::Empty
    (block, underblock, null)::Block
    isEmpty(empty) == null

    isHolding(gripper) == block

    clearunderblock::IsClear
    isClearDom(clearunderblock) == underblock
    isClear(clearunderblock) == true
  end
  l => begin
    null => null
    block => block
    underblock => underblock
  end
  r => begin
    null => null
    block => block
    underblock => underblock
  end
end;
```

```{julia}
#| echo: false
#| output: false
unstack = DRule(unstack);
unstack_rule = make_rule(unstack, yColorBlocksworld);
```
:::

::: {.column width=90%"}
::: {style="text-align:center;"}
[unstack action applied to the initial state $X$]{style="font-size:70%;margin-left:-80px"}
![](assets/BlocksworldUnstackAction.svg){.absolute left="450" width="600"}
:::

::: {.callout-color2 style="font-size:70%;margin-left:-70px;margin-top:325px;"}
**$\catSet{C}$ and DPO rewriting** [@Aguinaldo2023]

- States and actions are compatible with functorial data migrations
- Preserves the structure of the schema category
<!-- - Accounts for implicit structure by constructing $\cat{C}$-sets using [colimit of representables]{.define} -->
- Finding morphisms, e.g. $\mathrm{Pre} \hookrightarrow X$, has runtime complexity of $O(n^k)$ where $k$ is the number of elements in $\mathrm{Pre}$ and $n$ is the number of elements in $X$
:::

:::

::::

## Planning using $\catSet{C}$ and DPO Rewriting

::: columns

::: {.column width="40%"}
::: {style="margin-top:-10px;"}
![](assets/forwardplan.svg){fig-align="center" height="600"}
:::
:::

::: {.column width="60%"}

::: {style="font-size:80%"}
::: {.callout-color2}
Existing state-space planning algorithms can be adapted to work with this planning representation [[@Aguinaldo2024dissertation]]{style="font-size:80%"}. 
:::

**Example**: `ForwardPlan()` executes depth-first search (DFS) to find a sequence of DPO rewrite rules, i.e. actions.
:::

```{.julia style="height:400px;font-size:90%"}
function ForwardPlan(world::ACSet, goal::ACSet, actions::Dict, 
                      action_limits::Dict, action_usage::Dict, 
                      plan::List)

  # Exit criteria: goal is reached if there is a monic morphism from goal to world
  if homomorphism(goal, world, monic=true) !== nothing 
    println("Goal reached.")
    return plan
  end

  # Find applicable actions for the current world state
  applicable = find_applicable_actions(world, actions)

  # Backtrack criteria: no applicable actions
  if length(applicable) <= 0
    throw("No applicable actions found! Terminate path...")
  end

  # Iterate over all applicable actions
  for action in applicable
    action_name = action.first
    match_morphism = action.second

    # Backtrack criteria: action applied too many times
    try
      if action_usage[action_name] >= action_limits[action_name]
        println("Abort path. Action used too many times.")
        continue
      end
    catch
      # Initialize action usage if it doesn't exist
      action_usage[action_name] = 1  
    end

    # Save current world state for backtracking
    prev_world = world
    selected_action = action[action_name].rule

    # Apply the selected action to the current world state
    try
      world = rewrite(selected_action, world)
    catch e
      throw("Could not apply action!")
    end

    # Record the action and corresponding match morphism in the current plan
    append!(plan, [selected_action => match_morphism])

    try
      # Recursively call ForwardPlan with updated world state
      plan = ForwardPlan(world, goal, actions, action_limits, 
                          action_usage, plan)
      return plan
    catch e
      # Backtrack to previous world state if path fails
      world = prev_world
      pop!(plan)
      println("Path failed. Try a different path.")
    end
  end

  # If no valid plan is found, report failure
  println("No plan found.")
end
```

:::

:::

## Transfer using Functorial Data Migration

::: columns

::: {.column width="50%"}

::: {.callout-color2 style="margin-top:40px;"}
[**High-level Steps in Analogical Plan Transfer**]{style="font-size:100%"}

::: {style="font-size:75%"}
1. **Define the Source Domain**: Start by defining the ontology, $\cat{D}_S$, and actions, $A_S$, for the source domain, $\textbf{D}_S$.
2. **Define the Planning Problem**: Establish the initial and goal states, $P_S = (I, G)$ within domain $\textbf{D}_S$.
3. **Plan**: Solve for a valid plan, $\pi_S$, that solves for $P_S$ within domain $\textbf{D}_S$.
4. **Define the Target Domain Ontology**: Specify the target ontology, $\cat{D}_T$, in the new domain, $\textbf{D}_T$.
5. **Align Ontologies**: Create a translation map, $F: \cat{D}_T \rightarrow \cat{D}_S$, linking the types and predicates from the target domain ontology to the source domain ontology.
6. **Transfer the Plan**: Use the translation map to transfer the grounded plan via $\Delta_F$, resulting in $\pi_T$.
7. **Validate the Plan**: Check that the end state after $\pi_T$ contains $\Delta_F(G)$.

[[@Aguinaldo2024]]{style="font-size:80%"}
:::
:::

:::

::: {.column width="50%"}

::: {style="border: 1px solid #000000;padding:5px;margin-top:-5px;"}
![**Step #5** Align the ontologies](assets/StructuralAnalogyTranslationFunctor.svg){fig-align="center"}
:::

::: {style="border: 1px solid #000000;padding:5px;margin-top:5px;"}
![**Step #6** and **#7** Transfer and Validate the Plan](assets/PlanTransfer.svg){fig-align="center"}
:::

:::

:::

## A review

:::{style="text-align:center;margin-top:15px;"}
![](assets/demo/demo-annotated.gif){width="900"}
:::

::: {style="font-size:70%;margin-top:-20px;text-align:center;"}
The frame rate is _not_ proportional to the speed of computation.
:::

## Advantages and Limitations of Categorical Structure

::: columns

&nbsp;
&nbsp;
&nbsp;

::: {.column width="50%"}
::: {.callout-color style="padding:10px;border-radius:10px;height:400px"}
[**Advantages**]{.dark-font-color style="font-size:120%"}

- Preserves ontological structure when applying actions and transferring plans
- Predictable runtime complexity w.r.t. PDDL and its extensions, e.g. typing and transitive closure constraints
- Generalized transfer for pair of domains
- Action (skill) generation
:::
:::

::: {.column width="50%"}
::: {.callout-color style="padding:10px;border-radius:10px;height:400px;"}
[**Limitations**]{.dark-font-color style="font-size:110%"}

- Reliance on advanced mathematical theory
- Higher runtime complexity for checking applicability of actions, $O(n^k)$, w.r.t. PDDL, $O(nk)$
- Depends on proper (functorial) ontological alignment
- Difficulty handling structurally dissimilar domains
:::
:::

:::

::: {style="text-align:center;margin-top:20px"}
[@Aguinaldo2024dissertation]
:::

# Future Work and Conclusion

## Areas of Future Work

::: {.callout-color .dark-font-color style="margin-top:20px;"}
**Empirical and Theoretical Scaling Studies**
:::

::: {style="margin-left:30px;"}
- Scale by the size of the ontology
- Scale by the number of elements
- Scale by the number of actions in a plan
- Scale by varying number of preconditions
- Mathematical analysis of ontological alignment maps
:::

::: {.callout-color .dark-font-color style="position: relative; margin-top:10px;"}
**A Software Tool for Category Theory-Based Planning and Plan Transfer**
:::

::: {style="margin-left:30px;"}
- Run planners 
- Automate discovery of functorial ontology alignments
- Perform analogical plan transfer
- Compose plans with other plans using sequential transfer
- Check that plans satisfy high-level behaviors using hierarchical transfer
:::

## Some Potential Applications

::: {style="margin-top:100px;"}
::: columns

::: {.column width="50%"}
::: {style="text-align:center;"}
![Source: Siemens](assets/siemensrobotarm.jpg){width="500"}

Standards and Privacy in Manufacturing

::: {style="font-size:80%"}
_Abstract robot plans can be transferred to manufacturer-specific contexts while preserving behavior_

:::
:::
:::

::: {.column width="50%"}
::: {style="text-align:center;"}
![Source: CNN](assets/femadisasterresponse.jpeg){width="500"}

Interoperability in Mission Planning

::: {style="font-size:80%"}
_Mission plans that coordinate various agencies can be adapted to tackle different disaster types_

:::
:::
:::

:::

:::

<!-- ::: {style="text-align:center;"}
::: {style="border: 2px solid #000000;border-radius:10px;padding:10px;"}
![](assets/MissionPlanning.svg){width="400"}
::: -->

<!-- ::: {style="margin-top:-20px;"}
Interoperability during Mission Planning
:::
::: --> 


## Conclusion

::: columns

::: {.column width="70%"}
::: {.callout-color style="font-size:85%;margin-top:10px;"}
[**Purpose**]{.dark-font-color}

Allow robots to [**reuse old task plans**]{.define} to solve new problems

[**Gap**]{.dark-font-color}

In robot transfer learning, there is little attention given to [**task-level plan transfer**]{.define}.

[**Research**]{.dark-font-color}

- Propose a conceptual framework for discussing types of task-level plan transfer, namely [**sequential, hierarchical, and analogical transfer**]{.define}
- Introduce a mathematical framework that validates each type of transfer based on [**symmetric monoidal categories, functors, $\cat{C}$-sets, DPO rewriting**]{.define} from category theory

[**Future Work**]{.dark-font-color} 

- Empirical and theoretical [**scaling studies**]{.define}
- Develop a [**software tool**]{.define} for category theory-based planning and plan transfer
:::

:::

::: {.column width="30%"}
::: {style="text-align:center;"}
![](assets/plantransferframework_vertical.svg){width="300"}
:::
:::

:::

## Research Activities (1 of 2) {.smaller}

::: {style="margin-top:20px;"}
[**Papers and Pre-prints**]{style="font-size:120%;"}

1. <u>Aguinaldo, A.</u>, Patterson, E., Regli, W. Automating Transfer of Robot Task Plans using Functorial Data Migrations. **arXiv pre-print (under revision IEEE-TASE 2024)**.
2. <u>Aguinaldo, A.</u>, Patterson, E., Fairbanks, J., Regli, W., & Ruiz, J. A Categorical Representation Language and Computational System for Knowledge-Based Planning. **2023 AAAI Fall Symposium on Unifying Representations for Robot Application Development - [Best Paper]{.define}**. 
3. <u>Aguinaldo, A.</u>, Regli W. Modeling traceability, change information, and synthesis in autonomous system design using symmetric delta lenses. **ICRA Compositional Robotics Workshop 2022**.
4. <u>Aguinaldo, A.</u>, Regli W. Encoding Compositionality in Classical Planning Solutions. **IJCAI Workshop on Generalization in Planning 2021**.
5. <u>Aguinaldo, A.</u>, Regli W. A Graphical Model-Based Representation for Classical AI Plans using Category Theory. **ICAPS 2021 Workshop on Explainable AI Planning**.
6. <u>Aguinaldo, A.</u>, Bunker J., Pollard B., Shukla A., Canedo A., Quiros G., Regli W. RoboCat: A Category Theoretic Framework for Robotic Interoperability Using Goal-Oriented Programming. **IEEE Transactions on Automation Science and Engineering**, 2019. doi: 10.1109/TASE.2021.3094055.

[**Community Service**]{style="font-size:120%"}

- Co-author of [Relational Thinking: From Abstractions to Applications](https://toposinstitute.github.io/RelationalThinking-Book/intro.html) (2024) digital textbook
- Open-source contributor to [AlgebraicJulia](https://www.algebraicjulia.org/)
- Local organizer of the Applied Category Theory (ACT) conference, [2023](https://act2023.github.io/)
- Co-organizer of ICRA Compositional Robotics: Mathematics and Tools, [2023](https://idsc.ethz.ch/research-frazzoli/workshops/compositional-robotics-2023.html)
- Co-organizer of The Adjoint School, [2022](https://adjointschool.com/2022.html), [2023](https://adjointschool.com/2023.html)
- Student of The Adjoint School, [2021](http://adjointschool.com/2021.html)
:::

## Research Activities (2 of 2) {.smaller}

::: {style="margin-top:20px;"}
[**Talks**]{style="font-size:120%"}

- "Analogical Plan Transfer in Robotics using Functorial Data Migrations" at **AMS Special Session on Applied Category Theory, II** in 2025
- "'What's the plan?', asked my robot" at **JuliaCon** in 2024
- "A Categorical Representation Language and Computational System for Knowledge-Based Planning" at **AAAI Fall Symposium on Unifying Representations for Robot Application Development** in 2023 
- "A Category Theoretic Approach to Planning in a Complex World" at **Microsoft Future Leaders in Robotics and AI Seminar Series** in 2023 
- "Contextual affordances in context-aware autonomous systems" at **NIST Compositional Structures for Systems Engineering and Design Workshop** in 2022 and **AMS JMM 2023 Special Session on Applied Category Theory** in 2023
- "Category theory for automated planning and program compilation in robotics" at **Topos Berkeley Seminar** in 2022
- "Applications of category theory to automated planning and program compilation in robotics" at **Xerox PARC Design Seminar** in 2022
- "Modeling traceability, change information, and synthesis in autonomous system design using symmetric delta lenses" at **ICRA Compositional Robotics Workshop** in 2022
- "Encoding Compositionality in Classical Planning Solutions" at **IJCAI Workshop on Generalization in Planning** in 2021
- "A Graphical Model-Based Representation for Classical AI Plans using Category Theory" at **ICAPS Explainable AI Planning Workshop** in 2021
- "Polynomial Functors in Catlab" at the **Applied Category Theory Conference** in 2021 
- "Diary of a software engineering using categories" at **Topos Institute: Berkeley Seminar** and **Lógicos em Quarentena (LQ) Seminar** in 2021
- "Category Theory for Software Modeling and Design" at **Hunter College Applied Mathematics Seminar** in 2020
:::

## Acknowledgements {.smaller}

::: columns

::: {.column width="33%"}
[**Research**]{style="font-size:120%;margin-top:-40px;"}

- [**Bill Regli**]{.define}, [_UMD (Advisor)_]{.light-font-color}
- [**Dana Nau**]{.define}, [_UMD_]{.light-font-color}
- [**Yiannis Aloimonos**]{.define}, [_UMD_]{.light-font-color}
- [**Dinesh Manocha**]{.define}, [_UMD_]{.light-font-color}
- [**Huan Xu**]{.define}, [_UMD_]{.light-font-color}
- [**Mark Fuge**]{.define}, [_UMD/ETH Zurich_]{.light-font-color}
- [**Eswaran Subrahmanian**]{.define}, [_CMU/NIST_]{.light-font-color}
- Spencer Breiner, [_NIST_]{.light-font-color}
- Evan Patterson, [_AlgebraicJulia_]{.light-font-color}
- James Fairbanks, [_AlgebraicJulia_]{.light-font-color}
- Kristopher Brown, [_AlgebraicJulia_]{.light-font-color}
- Kevin Arlin, [_AlgebraicJulia_]{.light-font-color}
- Owen Lynch, [_AlgebraicJulia_]{.light-font-color}
- Brendan Fong, [_Topos Institute_]{.light-font-color}
- David Spivak, [_Topos Institute_]{.light-font-color}
- Arquimedes Martinez Canedo, [_Siemens_]{.light-font-color}
- Jacob Bunker, [_ARLIS_]{.light-font-color}
- Gustavo Quiros Araya, [_Siemens_]{.light-font-color}
- Ankit Shukla, [_Siemens_]{.light-font-color}
- Lazlo Nemeth, [_Siemens_]{.light-font-color}
:::

::: {.column width="33%"}

- Blake Pollard, [_former NIST_]{.light-font-color}
- Zinovy Diskin, [_McMaster Univ._]{.light-font-color}
- Ian Levitt, [_NASA_]{.light-font-color}
- Andrew Cohen, [_Drexel University_]{.light-font-color}

[**Support**]{style="font-size:120%;margin-top:-40px;"}

- Pedro Rodriguez, [_Johns Hopkins APL_]{.light-font-color}
- Michael Castle, [_Johns Hopkins APL_]{.light-font-color}
- Elisha Peterson, [_Johns Hopkins APL_]{.light-font-color}
- Emily Brown, [_Johns Hopkins APL_]{.light-font-color}
- Gina Marshall-Johnson, [_Johns Hopkins APL_]{.light-font-color}
- John Piorkowski, [_Johns Hopkins APL_]{.light-font-color}
- Matthew Dinmore, [_Johns Hopkins APL_]{.light-font-color}
- Rob Nichols, [_Johns Hopkins APL_]{.light-font-color}
- Bill Blackert, [_Johns Hopkins APL_]{.light-font-color}
- Christopher Gifford, [_Johns Hopkins APL_]{.light-font-color}

[**Funding**]{style="font-size:120%;margin-top:-40px;"}

- Johns Hopkins University Applied Physics Lab Part-Time Study Program
- Adv. Robotics for Manu. ARM-18-01
- DARPA #HR00112220004 
:::

::: {.column width="33%"}

[**Friends and Family**]{style="font-size:120%;margin-top:-40px;"}

- Priyaa Varshinee Srinivasan, [_Tallin Univ. of Tech._]{.light-font-color}
- Sophie Libkind, [_Topos Institute_]{.light-font-color}
- David Jaz Myers, [_Topos Institute_]{.light-font-color}
- Elena Di Lavore, [_Univ. of Pisa_]{.light-font-color}
- Nathan Haydon, [_Univ. of Waterloo_]{.light-font-color}
- Ana Luiza da Conceição Tenorio, [_U. São Paulo_]{.light-font-color}
- Nelson Niu, [_Univ. of Washington_]{.light-font-color}
- Joseph Moeller, [_Caltech_]{.light-font-color}
- Daniel Cicala, [_Southern Connecticut State Univ._]{.light-font-color}
- Paul Dancstep, [_"Relational Thinking"_]{.light-font-color}
- John Kanu, [_UMD_]{.light-font-color}
- Samuel Matos, [_Johns Hopkins APL_]{.light-font-color}
- Alison Albin, [_Johns Hopkins APL_]{.light-font-color}
- Gene Whipps, [_Johns Hopkins APL_]{.light-font-color}
- Vikram Saraph, [_Johns Hopkins APL_]{.light-font-color}
- Jonathan Cohen, [_Johns Hopkins APL_]{.light-font-color}
- Jose Aguinaldo
- Annie Aguinaldo
- Kristene Aguinaldo
- Alex Ly
:::

:::

## {background-image="assets/thankyou.svg" background-size="contain"}

# Appendix

## Summary of Research Contributions 

::: {style="font-size:60%"}

::: {.callout-color2 style="margin-top:10px; padding:5px;"}
**1. A Conceptual Framework for Task Plan Transfer**

This research surveys the literature and classifies methods for plan and program reuse in terms of sequential transfer, a hierarchical transfer, or an analogical transfer.
:::

::: {.callout-color2 style="margin-top:10px; padding:5px;"}
**2. A Method for Validating Sequential Composition of Plans**

This research introduces a method using symmetric monoidal categories and string diagrams to validate the sequential composition of actions and plans, ensuring that actions are composed coherently to support sequential transfer.
:::

::: {.callout-color2 style="margin-top:10px; padding:5px;"}
**3. The RoboCat Framework for Hierarchical Plan Compilation**

The research proposes a functorial approach to compiling from high-level task specifications to low-level robot commands, called RoboCat, that supports the coherent interchange of programming modules required for hierarchical transfer.
:::

::: {.callout-color2 style="margin-top:10px; padding:5px;"}
**4. A New Representation Language for Task Planning**

This research develops a planning representation language based on $\cat{C}$-sets and double-pushout (DPO) rewriting is developed to manage highly-connected and structured knowledge as a prerequisite to analogical transfer.
:::

::: {.callout-color2 style="margin-top:10px; padding:5px;"}
**5. An Algorithm for Analogical Plan Transfer**

This research introduces a novel algorithm that leverages ontology alignment maps and functorial data migrations in order to analogically translate actions and plans from one planning domain to another.
:::

::: {.callout-color2 style="margin-top:10px; padding:5px;"}
[**6. Case Studies Demonstrating Types of Plan Transfer**]{style="font-size:130%"}

The eﬀectiveness of the proposed framework is demonstrated through case studies within various planning domains, such as in Blocksworld, machine-tending, assembly, and a kitchen domain derived from the AI2THOR simulation. 
:::

:::

## Why now?

::: columns

::: {.column width="80%"}

::: {.tablenoborders style="font-size:77%; width=100%; margin-top: 00px; margin-left: -20px;"}
| | | |
|--:|:--|:--|
| [&#8226;]{.robotics-fc style="font-size:18pt;"} | **2024** | Current applications in robotics span healthcare, search and rescue, education, food processing, etc. [@Licardo2024] |
| [&#8226;]{.robotics-fc style="font-size:18pt;"} [&#8226;]{.ct-fc style="font-size:18pt;"} | **2023** | Survey of transfer learning in robotics [@Jaquier2023], Categorical rewriting for $\cat{C}$-sets introduced [@Brown2021] |
| [&#8226;]{.ct-fc style="font-size:18pt;"} | **2021** | Programming with $\cat{C}$-sets implemented [@Patterson2021] |
| [&#8226;]{.robotics-fc style="font-size:18pt;"} | **2015** | DARPA Robotics Challenge for disaster response applications [@darpaRoboticsChallenge] |
| [&#8226;]{.ct-fc style="font-size:18pt;"} [&#8226;]{.planning-fc style="font-size:18pt;"} [&#8226;]{.planning-fc style="font-size:18pt;"} | **2012** | Category theory for knowledge representation using functorial data migrations and $\cat{C}$-sets [@Spivak2012], Deep Learning [@Hinton2012] |
| [&#8226;]{.planning-fc style="font-size:18pt;"} | **2009** | Survey of transfer learning for reinforcement learning domains [@Taylor2009] |
| [&#8226;]{.planning-fc style="font-size:18pt;"} [&#8226;]{.planning-fc style="font-size:18pt;"} | **2005** | Transfer learning for planning tasks [@Fern2006], DARPA Transfer Learning challenge [@Gasser2005] |
| [&#8226;]{.planning-fc style="font-size:18pt;"} | **1998** | PDDL - Planning Domain Definition Language introduced [@Ghallab1998] |
| [&#8226;]{.planning-fc style="font-size:18pt;"} | **1997** | Transfer learning between machine-learning tasks [@Caruana1997] |
| [&#8226;]{.planning-fc style="font-size:18pt;"} | **1994** | Hierarchical Task Networks (HTNs) in planning introduced [@Erol1994] |
| [&#8226;]{.ct-fc style="font-size:18pt;"} | **1991** | Graphical notation for monoidal categories (string diagrams) [@Joyal1991] |
| [&#8226;]{.planning-fc style="font-size:18pt;"} [&#8226;]{.robotics-fc style="font-size:18pt;"}| **1971** | STRIPS - Stanford Research Institute problem solver developed [@Fikes1971], Shakey robot - first robot using AI [@Nilsson1984] |
| [&#8226;]{.robotics-fc style="font-size:18pt;"} | **1954** | Unimate robot - first industrial robotic arm [@unimate] |
| [&#8226;]{.ct-fc style="font-size:18pt;"} | **1945** | Category theory introduced [@Eilenberg1945] |
: {tbl-colwidths="[10,10,100]"}

:::

<!--
Reusing robot plans and programs using transfer learning because robots are being used in different applications

1945 Category Theory
1954 Unimate robot: first industrial robotic arm
1971 STRIPS
1972 Shakey robot: first robot using AI
1991 Graphical notation for monoidal categories (string diagrams) [@Joyal1991]
1994 HTNs
1995 Transfer learning between machine-learning tasks [@Caruana1995,@Thrun1996]
1998 PDDL
2000 Roomba: first home automation robot
2005 Transfer learning for planning tasks [@Fern2006], DARPA Transfer Learning challenge
2008 Using ontologies to inform task planning [@Galindo2008]
2009 Transfer Learning for Reinforcement Learning Domains [@Taylor2009]
2012 Category theory for knowledge representation, deep learning surge [@Hinton2012]
2015 DARPA Robotics Challenge (https://www.darpa.mil/program/darpa-robotics-challenge)
2022 Categorical rewriting for C-sets
2023 Transfer learning in robotics survey paper [@Jaquier2023]
2024 Current applications in robotics span healthcare, search and rescue, education, food processing, etc. [@Licardo2024]
-->

:::

::: {.column width="20%"}

::: {data-id="circle1" .planning-bg .planning-fc style="width: 150px; height: 150px; border-radius: 75px; margin-left: 0px; margin-top: 150px; position: absolute; display: flex; justify-content: center; align-items: center; font-size: 20px;"}
_AI_
:::

<!-- Robotics Circle -->
::: {data-id="circle2" .robotics-bg .robotics-fc style="width: 150px; height: 150px; border-radius: 75px; margin-left: 130px; margin-top: 150px; position: absolute; display: flex; justify-content: center; align-items: center; font-size: 20px;"}
_Robotics_
:::

<!-- Category Theory Circle -->
::: {data-id="circle3" .ct-bg .ct-fc style="width: 150px; height: 150px; border-radius: 75px; margin-left: 65px; margin-top: 250px; position: absolute; display: flex; justify-content: center; align-items: center; font-size: 20px;"}
_Category Theory_
:::

:::

:::

## Types of Analogies (in analogical plan transfer)

:::{style="text-align:center;margin-top:0px;"}
![](assets/typesofanalogies.svg){width="950"}

<!-- :::{style="margin-top:-30px;"}
[[@Aguinaldo2024dissertation]]{style="font-size:80%"}
::: -->
:::

## Sequential Transfer: An Overview

::: {style="text-align:center;font-size:80%"}
World states as a result of explicit (**bold**) and implicitly propagated literals.
:::

::: {style="text-align:center; margin-top:-25px;"}
![](assets/blocks_string_diagram.png)
:::

::: {.callout-color style="font-size:60%; margin-top:-30px"}
| **State** | **World State** | **Action** |
|:--:|:--:|:--:|
| **Initial** | **clear c**, **ontable c**, **clear b**, **ontable b**, **handempty**, **clear a**, **ontable a** | |
| **Step 1** | clear c, ontable c, **clear b**, **ontable b**, **handempty**, clear a, ontable | pick-up |
| **Step 2** | clear c, ontable c, **holding b**, **clear a**, ¬ontable b, ¬clear b, ¬handempty, ontable a | stack |
| **Step 3** | clear b, **clear c**, **ontable c**, **handempty**, on b a, ¬holding b, ¬clear a, ¬ontable b, ¬clear b, ¬handempty, ontable a | pick-up |
| **Step 4**  | **holding c**, **clear b**, ¬ontable c, ¬clear c, ¬handempty, on b a, ¬holding b, ¬clear a, ¬ontable b, ¬clear b, ¬handempty, ontable a | stack |
| **Goal** | clear c, handempty, **on c b**, ¬holding c, ¬clear b, ¬ontable c, ¬clear c, ¬handempty, **on b a**, ¬holding b, ¬clear a, ¬ontable b, ¬clear b, ¬handempty, ontable a | |
: {tbl-colwidths="[10,100,10]"}
:::

::: {.callout-color2 style="font-size:85%;margin-top:10px;text-align:center;"}
Strings diagrams can [**propagate preconditions and effects**]{.define}  of actions in a plan and [**check plan composition**]{.define}. [@Aguinaldo2021a]
:::


## Hierarchical Transfer: An Overview

::: {.callout-color style="font-size:85%;margin-top:10px;text-align:center;"}
The categories [$\cat{Task}$]{.define} (SMC), [$\cat{Virtual}$]{.define} (SMC), [$\cat{Motion}$]{.define} (category without monoidal structure) are defined. [@Aguinaldo2021]
:::

::: columns

::: {.column width="40%"}
:::{style="margin-top:20px;text-align:center;"}
![](assets/framework.png)
:::
:::

::: {.column width="60%"}
:::{style="margin-top:10px;text-align:center;border: 1px solid #000000;"}
![](assets/sd6.png)
:::
:::

:::

::: {.callout-color2 style="font-size:85%;margin-top:0px;text-align:center;"}
[**Functors between string diagrams**]{.define} can be used to guarantee abstract behavior is preserved. [@Aguinaldo2021]
:::

## References
